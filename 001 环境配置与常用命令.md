---
typora-copy-images-to: assets
---

# 001 GO环境搭建

## 安装GO

### 下载

下载地址：`https://golang.google.cn/dl/`

根据环境，下载所需版本

![1616400224920](assets/1616400224920.png)



### 配置GOROOT、GOPATH

**GOROOT**

- GOROOT表示Go语言的安装目录，将GOROOT的值设置为对应的安装目录。
- 此外，`GOROOT/bin`则包含GO提供的工具链，应将`GOROOT/bin`配置到环境变量PATH中，从而能够在全局中使用GO工具链。



**GOPATH**

 GO是编译型语言，编译时需要加载动态库文件。

- `GOPATH`是一个环境变量，用来表明你写的go项目的存放路径（工作目录）。
- `GOPATH`路径最好只设置一个，所有的项目代码都放到`GOPATH`的`src`目录下。
- 补充说明：Go1.8版本之前，`GOPATH`环境变量默认是空的，从Go1.8版本之后，Go开发包会在安装完成之后为`GoPATH`设置一个默认目录。
- 首先删除默认的GOPATH（在用户变量中），然后修改为自己想要的路径。

- 将工作目录中bin文件夹的路径添加到PATH变量中，这样便可以在任意地方执行生成的可执行文件。

> GOROOT和GOPATH分别指向系统安装路径和工作路径，这样的好处是自己编写的代码与系统文件分离。



## Go项目结构

在进行Go语言开发的时候，我们的代码总是会保存在`$GOPATH/src`目录下。

在工程经过`go build`、`go install`或`go get`等指令后，会将下载的第三方包源代码文件放在`$GOPATH/src`目录下， 产生的二进制可执行文件放在 `$GOPATH/bin`目录下，生成的中间缓存文件会被保存在 `$GOPATH/pkg` 下。

如果我们使用版本管理工具（Version Control System，VCS。常用如Git）来管理我们的项目代码时，我们只需要添加`$GOPATH/src`目录的源代码即可。`bin` 和 `pkg` 目录的内容无需版本控制。

### 适合个人开发者

我们知道源代码都是存放在`GOPATH`的`src`目录下，那我们可以按照下图来组织我们的代码。

![1550805203054](assets/1550805203054.png)



### 目前流行的项目结构

Go语言中也是通过包来组织代码文件，我们可以引用别人的包也可以发布自己的包，但是为了防止不同包的项目名冲突，我们通常使用`顶级域名`来作为包名的前缀，这样就不担心项目名冲突的问题了。

因为不是每个个人开发者都拥有自己的顶级域名，所以目前流行的方式是使用个人的github用户名来区分不同的包。

![1550805044488](assets/1550805044488.png)

举个例子：张三和李四都有一个名叫`studygo`的项目，那么这两个包的路径就会是：

```go
import "github.com/zhangsan/studygo"
```

和

```go
import "github.com/lisi/studygo"
```

以后我们从github上下载别人包的时候，如：

```bash
go get github.com/jmoiron/sqlx
```

那么，这个包会下载到我们本地`GOPATH`目录下的`src/github.com/jmoiron/sqlx`。



### 适合企业开发者

![1550806101915](assets/1550806101915.png)



## Go相关指令

```
Usage:

        go <command> [arguments]

The commands are:

        bug         start a bug report
        build       compile packages and dependencies
        clean       remove object files and cached files
        doc         show documentation for package or symbol
        env         print Go environment information
        fix         update packages to use new APIs
        fmt         gofmt (reformat) package sources
        generate    generate Go files by processing source
        get         add dependencies to current module and install them
        install     compile and install packages and dependencies
        list        list packages or modules
        mod         module maintenance
        run         compile and run Go program
        test        test packages
        tool        run specified go tool
        version     print Go version
        vet         report likely mistakes in packages

Use "go help <command>" for more information about a command.

Additional help topics:

        buildmode   build modes
        c           calling between Go and C
        cache       build and test caching
        environment environment variables
        filetype    file types
        go.mod      the go.mod file
        gopath      GOPATH environment variable
        gopath-get  legacy GOPATH go get
        goproxy     module proxy protocol
        importpath  import path syntax
        modules     modules, module versions, and more
        module-get  module-aware go get
        module-auth module authentication using go.sum
        module-private module configuration for non-public modules
        packages    package lists and patterns
        testflag    testing flags
        testfunc    testing functions

Use "go help <topic>" for more information about that topic.
```



**go build**

```
usage: go build [-o ouput] [-i][build flags][packages]
```

```
go build
go build .
go build hello.go
```

以上三种写法，都是使用当前目录编译的意思。因为忽略了packages,所以编译器自然就使用了当前目录进行编译。

go build本质上需要的是一个路径，让编译器可以找到哪些需要编译的go文件，packages其实是一个相对路径，是相对于GOROOT和GOPATH这两个环境变量的。

```
go build flysnow.org/tools
go build flysnow.org/tools/...
指定包的方式（编译包）和使用通配符，3个点表示匹配所有字符串，tools目录下的所有包
```



在其他目录下预将源代码编译成可执行文件：

`go build  /xxxx.com/username/projectname  projectname`

> go编译器会去 `GOPATH`的src目录下查找你要编译的`hello`项目
>
> 编译得到的可执行文件会保存在执行编译命令的当前目录下，如果是windows平台会在当前目录下找到`hello.exe`可执行文件。

使用`-o`参数来指定编译后可执行文件的名字：`go build -o heiheihei.exe`



**go clean**

在使用go build编译时，会产生编译生成的文件，尤其是在我们迁入代码的时候，并不想把我们生成的文件也签入到我们的Git代码库中，这是可以手动删除。

也可以使用go clean清理编译生成的文件，比如生成的可执行文件，生成obj对象等。

```
go clean [-i] [-r] [-n] [-x] [build flags] [packages]
```



**go run**

go build是先编译，然后我们在执行可以执行文件来运行程序。

go run是二合一，两步并一步

```
go run [build flags] [-exec xprog] gofiles... [arguments...]
```

go run 文件 参数  文件必须包含main包和main函数



**go env**

查看go环境信息，便于调试，排错



**go get**

可以从网上下载更新指定的包以及依赖包，并对它们进行编译和安装。

go get支持大多数版本控制系统（VCS），比如常用的git，通过它和包依赖管理结合，我们可以在代码中直接导入网络上的包供我们使用。

如果需要更新一个go工程，加-u标记即可。

-v标记，可以看到下载的进度以及更多的调试信息。



**go install**

和 go build类似，可以在编译后，把生成的可执行文件或者库安装到对应目录下，以供使用。

```
go install [build flags][packages]
Install compiles and installs the packages named by the import paths, along with their dependencies
```

它的用法和`go build`差不多，如果不指定一个包名，就使用当前目录。安装的目录都是约定好的，如果生成的是可执行文件，那么安装在`$GOPATH/bin`目录下；如果是可引用的库，那么安装在`$GOPATH/pkg`目录下。



**go fmt**

格式化代码并保存

本质调用是

```
gofmt -l -w
```



**go vet**

这个命令不会帮助开发人员写代码，但是它也很有用，因为它会帮助我们检查代码中常见的错误

- Printf这类函数调用时，类型匹配了错误的参数
- 定义常用的方法时，方法签名错误
- 错误的结构标签
- 没有指定字段名的结构字面量

```
package main
import(
	"fmt"
)

func main(){
	fmt.Printf("哈哈",3.14)
}
```

```
go vet
main.go:8: no formatting directive in Printf call
```

```
usage: go vet [-n] [-x] [build flags] [packages]
```



**go test**

该命令用于Go的单元测试，它也是接受一个包名作为参数，如果没有指定，使用当前目录。运行的单元测试必须符合go的测试要求

1. 写有单元测试的文件名，必须以_test.go结尾
2. 测试文件要包含若干个测试函数
3. 这些测试函数要以Test为前缀，还要接收一个*testing.T类型的参数

```go
package main

import "testing"

func TestAdd(t *testing.T){
	if Add(1,2) == 3{
		t.Log("1+2=3")
	}
	if Add(1,1) == 3{
		t.Error("1+1=3")
	}
}
```

这是一个单元测试，保存在main_test.go文件中，对main包里的Add(a,b int)函数进行单元测试，如果要运行这个单元测试，在该文件目录下，执行go test即可。




## GO交叉编译

`go build`的可执行文件默认都是当前操作系统可执行的文件

指定目标操作系统的平台和处理器架构即可交叉编译

```bash
SET CGO_ENABLED=0  // 禁用CGO
SET GOOS=linux  // 目标平台是linux
SET GOARCH=amd64  // 目标处理器架构是amd64
```

然后再执行`go build`命令，得到的就是能够在Linux平台运行的可执行文件。

Mac 下编译 Linux 和 Windows平台 64位 可执行程序：

```bash
CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build
CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build
```

Linux 下编译 Mac 和 Windows 平台64位可执行程序：

```bash
CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build
CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build
```

Windows下编译Mac平台64位可执行程序：

```bash
SET CGO_ENABLED=0
SET GOOS=darwin
SET GOARCH=amd64
go build
```



注意里面两个重要的环境变量`GOOS`和`GOARCH`。

其中`GOOS`指的是目标操作系统，它的可用值为：

`darwin、freebsd、linux、windows、android、dragonfly、netbsd、openbsd、plan9、solaris`

`GOARCH`指的是目标处理器的架构，目前支持的有：

`arm、arm64、386、amd64、ppc64、ppc64le、mips64、mips64le、s390x`



**For example:**

生成不同平台架构的可执行程序，只要改变这两个环境变量，比如要生成linux 64位的程序，命令如下：

```
GOOS=linux GOARCH=amd64  go build flysnow.org/hello
```

前面两个赋值，是更改环境变量，这样的好处是只针对本次运行有效，不会更改我们默认的配置，但`SET GOOS=darwin`会改变默认配置。



> Update 2021.03.29：发现SET GO111MODULE这个操作，在命令行设置值以后，也没有更改默认的配置，关闭命令行之后就没有了。



## VS Code安装与使用

- 应用商店搜索chinese，安装汉化包插件

- 应用商店搜索go，安装插件

- 打开项目文件夹，新建main.go文件

  ![1572331669375](assets/1572331669375.png)

- 输入以下代码

  ```go
  package main
  
  import "fmt"
  
  func main(){
  	println("hello world!")
  }
  ```

  > main.go表示项目入口  main()函数入口，main表示可生成可执行文件

- 右键main.go 在终端中打开，终端选择cmd，输入go build后生成可执行文件，默认为项目名，终端中输入项目名.exe，可输出hello world!

> 若在vscode打开的终端内，提示没有找到该命令，属性，兼容性，管理员身份运行
>
> 原因在于配置了系统变量，而不是用户变量，所以需要管理员权限

![1572331839741](assets/1572331839741.png)

- 插件的安装，在编辑的过程中，会弹出很多这类的框，一般都很难下载成功，去github下载

![1572331496541](assets/1572331496541.png)



