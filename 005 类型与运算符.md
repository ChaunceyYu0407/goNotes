---
typora-copy-images-to: assets
---

# 005 类型与运算符

类型可以是基本类型，如：==int、float、bool、string==；复合类型，如：==struct、array、slice、map、channel==；只描述类型的行为的，如：==interface==。

值类型：int、float、bool、string、array、struct

引用类型：ptr（指针）, slice、map、channel、func、interface

> 参见008 指针

引用类型它使用 nil 作为默认值（在 Objective-C 中是 nil，在 Java 中是 null，在 C 和 C++ 中是NULL或 0）。值得注意的是，Go 语言中不存在类型继承。

函数也可以是一个确定的类型，就是以函数作为返回类型。这种类型的声明要写在函数名和可选的参数列表之后，例如：

```
func FunctionName (a typea, b typeb) typeFunc
```



Go语言是一种静态类型的编程语言，所以在编译器进行编译的时候，就要知道每个值的类型，这样编译器就知道要分配多少内存，并且知道这段内存表示什么。这样做的好处是，编译器可以合理的使用这些值，进一步优化代码，提高执行效率，减少Bug。



> 

## 基本数据类型

### 布尔类型 bool

Go语言中以`bool`类型进行声明布尔型数据，布尔型数据只有`true`和`flase`两个值

注意：

- 布尔类型变量的默认值`false`
- Go语言中不允许将整型强制转换为布尔型
- 布尔型无法参与数值运算，也无法与其他类型进行转换



### 整型

| 类型   | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| uint8  | 无符号 8位整型 (0 到 255)                                    |
| uint16 | 无符号 16位整型 (0 到 65535)                                 |
| uint32 | 无符号 32位整型 (0 到 4294967295)                            |
| uint64 | 无符号 64位整型 (0 到 18446744073709551615)                  |
| int8   | 有符号 8位整型 (-128 到 127)                                 |
| int16  | 有符号 16位整型 (-32768 到 32767)                            |
| int32  | 有符号 32位整型 (-2147483648 到 2147483647)                  |
| int64  | 有符号 64位整型 (-9223372036854775808 到 9223372036854775807) |

> `unit8`是我们熟知的`byte`型，`int16`对应C语言中的`short`型，`int64`对应C语言中的`long`型



### 特殊的整型

|  类型   |                          描述                          |
| :-----: | :----------------------------------------------------: |
|  uint   | 32位操作系统上就是`uint32`，64位操作系统上就是`uint64` |
|   int   |  32位操作系统上就是`int32`，64位操作系统上就是`int64`  |
| uintptr |              无符号整型，用于存放一个指针              |

> 在使用`int`和`uint`类型时，不能假定它是32位或者64位的整型，而是考虑`int`和`uint`可能在不同平台上的差异



**注意事项：**

获取对象的长度的内建`len()`函数返回的长度可以根据不同平台的字节长度进行变化。实际使用中，map或切片的元素数量等都可以用`int`表示，==但是在涉及到二进制传输，读写文件的结构描述时，为了保持文件的结构不会受到不同编译目标平台字节长度的影响，不要使用`int`和`uint`==



### 浮点型

- GO语言支持两种浮点型数：`float32`和`float64`。这两种浮点型数据格式遵循`IEEE 754`标准：`float32`浮点数的最大范围约为`3.4e38`，可以用常量定义
- `math.MaxFloat32`; `float64`浮点数的最大范围约为`1.8e308`，可以使用一个常量定义`math.MaxFloat64`

- `float32`精确到小数点后7位，`float64`精确到小数点后15位。使用`==`或`!=`来比较浮点数时应当非常小心，在正式使用前测试对于精确度要求比较高的运算。



### 数字字面量语法

Go1.13版本之后引入了数字字面量语法，这样便于开发者以二进制、八进制或十六进制浮点数的格式定义数字，例如：

- v := 0b00101101， 代表二进制的 101101，相当于十进制的 45。 

- v := 0o377，代表八进制的 377，相当于十进制的 255。

- v := 0x1p-2，代表十六进制的 1 除以 2²，也就是 0.25。

  > .\main.go:68:17: 'p' exponent requires hexadecimal mantissa
  >
  > 只能用于十六级进制

- ==允许用 _ 来分隔数字，比如说：v := 123_456 等于 123456。



### 复数

`complex64`和`complex128`

复数有实部和虚部，`complex64`的实部和虚部为32位，`complex128`的实部和虚部为64位

```go
var c1 complex64
c1 = 1 + 2i
var c2 complex128
c2 = 2 + 3i
fmt.Println(c1)
fmt.Println(c2)
```

![1572443151980](assets/1572443151980.png)



如果实数部分和虚数部分的类型均为float32，那么类型为`complex64`的复数c可以通过以下方式来获得

```go
c = complex(re, im)
```

而函数

```go
real(c)
imag(c)
```

可以分别获得相应的实数和虚数部分。

- 复数支持和其他数字类型一样的运算，当使用等号`==`或不等号`!=`对复数进行比较运算时，注意对精确度的把握。
- `cmath`包中包含了一些操作复数的公共方法，接收的类型都是`complex128`。





### byte与rune类型

http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html

组成每个字符串的元素叫做“字符”，可以通过遍历或者单个获取字符串元素获得字符。 字符用单引号（’）包裹起来，如：

```go
var a := '中'
var b := 'x'
```

Go 语言的字符有以下两种：

1. `uint8`类型，或者叫 byte 型，代表了`ASCII码`的一个字符。
2. `rune`类型，代表一个 `UTF-8字符`。

当需要处理中文、日文或者其他复合字符时，则需要用到`rune`类型。`rune`类型实际是一个`int32`。Go 使用了特殊的 rune 类型来处理 Unicode，让基于 Unicode 的文本处理更为方便，也可以使用 byte 型进行默认字符串处理，性能和扩展性都有照顾。



**注意这个！**

```go
// 遍历字符串
func traversalString() {
	s := "hello沙河"
	for i := 0; i < len(s); i++ { //byte
		fmt.Printf("%v(%c) ", s[i], s[i])
	}
	fmt.Println()
	for _, r := range s { //rune
		fmt.Printf("%v(%c) ", r, r)
	}
	fmt.Println()
}
```

输出：

```bash
104(h) 101(e) 108(l) 108(l) 111(o) 230(æ) 178(²) 153() 230(æ) 178(²) 179(³) 
104(h) 101(e) 108(l) 108(l) 111(o) 27801(沙) 27827(河) 
```



因为UTF8编码下一个中文汉字由3~4个字节组成，所以我们不能简单的按照字节去遍历一个包含中文的字符串，否则就会出现上面输出中第一行的结果。

字符串底层是一个byte数组，所以可以和`[]byte`类型相互转换。==字符串是不能修改的 字符串是由byte字节组成，所以字符串的长度是byte字节的长度==。 **rune类型用来表示utf8字符，一个rune字符由一个或多个byte组成。**



补充

在ASCII码表中，A的值是65，而使用16进制表示则为41，所以下面的写法是等效的

```go
var ch byte = 65
var ch byte = '\x41'
```

> `\x`总是紧跟着长度为2的16进制数
>
> 另外一种是可能的写法是`\`后面紧跟着长度为3的8进制数，例如`\377`



- 在文档中，一般使用格式`U+hhhh`来表示Unicode，其中h表示一个16进制数。

- 在书写Unicode字符时，需要在16进制数之前加上前缀`\u`或者`\U`

- 因为Unicode至少占用2个字节，所以我们使用`int`或`int16`类型来表示

- 前缀 `\u` 则总是紧跟着长度为 4 的 16 进制数，前缀 `\U` 紧跟着长度为 8 的 16 进制数。

```go
var ch int = '\u0041'
var ch2 int = '\u03B2'
var ch3 int = '\U00101234'
fmt.Printf("%d - %d - %d\n", ch, ch2, ch3) // integer
fmt.Printf("%c - %c - %c\n", ch, ch2, ch3) // character
fmt.Printf("%X - %X - %X\n", ch, ch2, ch3) // UTF-8 bytes
fmt.Printf("%U - %U - %U", ch, ch2, ch3) // UTF-8 code point
//65 - 946 - 1053236
//A - β - r
//41 - 3B2 - 101234
//U+0041 - U+03B2 - U+101234
```

格式化说明符 `%c` 用于表示字符；当和字符配合使用时，`%v` 或 `%d` 会输出用于表示该字符的整数；`%U` 输出格式为 U+hhhh 的字符串（另一个示例见第 5.4.4 节）。

包 `unicode` 包含了一些针对测试字符的非常有用的函数（其中 `ch` 代表字符）：

- 判断是否为字母：`unicode.IsLetter(ch)`
- 判断是否为数字：`unicode.IsDigit(ch)`
- 判断是否为空白符号：`unicode.IsSpace(ch)`

这些函数返回一个布尔值。包 `utf8` 拥有更多与 rune 类型相关的函数。



### 字符串

Go语言中的字符串以原生数据类型出现，使用字符串就像使用其他原生数据类型一样。Go语言里的字符串的内部实现使用`utf-8`编码。字符串的值为`双引号""`中的内容，可以在 Go语言的源码中直接添加非ASCII码字符，例如：

```go
s1 := "hello"
s2 := "你好"
```



#### 字符串转义符

| 转义符 |                含义                |
| :----: | :--------------------------------: |
|  `\r`  |         回车符（返回行首）         |
|  `\n`  | 换行符（直接跳到下一行的同列位置） |
|  `\t`  |               制表符               |
|  `\'`  |               单引号               |
|  `\"`  |               双引号               |
|  `\\`  |               反斜杠               |

```go
package main
import (
    "fmt"
)
func main() {
    fmt.Println("str := \"c:\\Code\\lesson1\\go.exe\"")
}
```

![1572445804891](assets/1572445804891.png)



#### 多行字符串

Go语言中要定义一个多行字符串时，就必须使用`反引号`字符：

```
s1 := `第一行
第二行
第三行
`
fmt.Println(s1)
```



反引号间换行将被作为字符串中的换行，但是所有的转义字符均无效，文本将会原样输出

```go
package main
import (
    "fmt"
)
func main() {
	s1 := `test1
	test2
	test3
	`

	s2 := `test1
test2\n
test3\n`
	fmt.Println(s1)
	fmt.Println(s2)
}
```

![1572446402668](assets/1572446402668.png)



#### 字符串的常用操作

|                方法                 |      介绍      |
| :---------------------------------: | :------------: |
|              len(str)               |     求长度     |
|           +或fmt.Sprintf            |   拼接字符串   |
|            strings.Split            |      分割      |
|          strings.contains           |  判断是否包含  |
| strings.HasPrefix,strings.HasSuffix | 前缀/后缀判断  |
| strings.Index(),strings.LastIndex() | 子串出现的位置 |
| strings.Join(a[]string, sep string) |    join操作    |



#### 修改字符串

要修改字符串，==需要先将其转换成`[]rune`或`[]byte`，完成后再转换为`string`。==无论哪种转换，都会重新分配内存，并复制字节数组。

```go
func changeString() {
	s1 := "big"
	// 强制类型转换
	byteS1 := []byte(s1)
	byteS1[0] = 'p'
	fmt.Println(string(byteS1))

	s2 := "白萝卜"
	runeS2 := []rune(s2)
	runeS2[0] = '红'
	fmt.Println(string(runeS2))
}
```



### 类型转换

**Go语言中只有强制类型转换，没有隐式类型转换。**该语法只能在两个类型之间支持相互转换的时候使用。

强制类型转换的基本语法如下：

```bash
T(表达式)
```

其中，T表示要转换的类型。表达式包括变量、复杂算子和函数返回值等.

比如计算直角三角形的斜边长时使用math包的Sqrt()函数，该函数接收的是float64类型的参数，而变量a和b都是int类型的，这个时候就需要将a和b强制类型转换为float64类型。

```go
func sqrtDemo() {
	var a, b = 3, 4
	var c int
	// math.Sqrt()接收的参数是float64类型，需要强制转换
	c = int(math.Sqrt(float64(a*a + b*b)))
	fmt.Println(c)
}
```





### 小结

基本类型是Go语言自带的类型，比如数值类型，浮点型，字符类型和布尔类型，它们本质上是原始类型，也就是不可改变，所以对它们进行操作，一般都会返回一个新创建的值。

==所以把这些值传递给函数时，其实传递的是一个值的副本==

```go
func main(){
	name:="张三"
	fmt.Println(modift(name))
	fmt.Println(name)
}

func modify(s string) string{
	s=s+s
	return s
}
```

基本类型因为是拷贝的值，并且在对他进行操作的时候，生成的也是新创建的值，所以这些类型在多线程里是安全的，我们不用担心一个线程的修改影响了另外一个线程的数据。



## 引用类型

它的修改可以影响到任何引用它的变量

引用类型有`切片`，`map`，`接口`，`函数类型`以及 `chan`

引用类型之所以可以引用，是因为我们创建引用类型的变量，其实是一个标头值，标头值里包含一个指针，指向底层的数据结构，当我们在函数中传递引用类型时，其实传递的是这个标头值的副本，它所指向的底层结构并没有被复制传递，这也是引用类型传递高效的原因。

==本质上，我们可以理解函数的传递都是值传递，只不过引用类型传递的是一个指向底层数据的指针，所以我们在操作的时候，可以修改共享的底层数据的值，进而影响到所有引用到这个共享底层数据的变量。==



## 结构类型

结构类型是用来描述一组值的，比如一个人有身高体重名字和年龄等，本质上是一种聚合型的数据类型。

```go
type person struct{
	age int
	name string
}
var p person
jim := person{10, "Jim"}
```

这个值的顺序很重要，必须和结构体里声明字段的顺序一致，当然我们也可以不按顺序，此时，需要标明变量，

```go
jim := person{name:"Jim",age:10}
```



除了基本的原始类型外，结构体内的值也可以是引用类型，或者自己定义的其他类型。具体选择类型，要根据实际情况，比如是否允许修改值本身，如果允许的话，可以选择引用类型，如果不允许的话，则需要使用基本类型。

==函数传参是值传递，所以对于结构体来说也不例外，结构体传递的是其本身以及里面的值的拷贝。如果传递的是指针，或者引用类型则会修改值。==



## 自定义类型

Go语言支持我们自定义类型，也可以叫做类型别名。

比如上述的结构类型，或者下面的

```go
type Duration int64
```

基于一个现有的类型创建一个新类型，这种也是使用 type关键字，但是这里我们注意Duration是基于int64创建，但是它们不能互相赋值，==且新类型不会拥有原类型所附带的方法==。

```go
type Duration int64

var dur Duration
dur =int64(100)
fmt.Println(dur)
//报错，不能互相转换
```

> 这样做的好处是能够提高代码可读性



## 运算符

### 算术运算符

| 运算符 | 描述 |
| ------ | ---- |
| +      | 相加 |
| -      | 相减 |
| *      | 相乘 |
| /      | 相除 |
| %      | 求余 |

注意：

- `++自增`和`--自减`在Go语言中是单独的语句，并不是运算符

- Go在进行字符串拼接时允许使用对运算符`+`的重载，但Go本身不允许开发者进行自定义的运算符重载
- `/`对于整数运算而言，结果依旧为整数
- 取余运算符只能作用于整数
- 整数除以0可能导致程序崩溃，会引发panic
- 浮点数除以0.0会返回一个无穷尽的结果，使用`+Inf`表示

- 在运算时**溢出**不会产生错误，Go会简单地将超出位数抛弃，如果需要范围无限大的整数或者有理数，可以使用标准库中的`big`包，该包提供了类似`big.Int`和`big.Rat`这样的类型。



### 关系运算符

| 运算符 | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| ==     | 检查两个值是否相等，如果相等返回True，否则返回False。        |
| !=     | 检查两个值是否不相等，如果不相等返回True，否则返回False。    |
| >      | 检查左边值是否大于右边值，如果返回True，否则返回False。      |
| \>=    | 检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。 |
| <      | 检查左边值是否小于右边值，如果是返回 True 否则返回 False。   |
| <=     | 检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。 |



### 逻辑运算符

| 运算符 | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| &&     | 逻辑AND运算符。如果两边的操作数都是True，则为True，否则为False。 |
| \|\|   | 逻辑OR运算符。如果两边的操作数有一个True，否则为False。      |
| ！     | 逻辑NOT运算符。如果条件为True，则为False，否则为True。       |

- 在Go语言中，&&和||是具有快捷性质的运算符，当运算符左边表达式的值已经能够决定整个表达式的值时，运算符右边的表达式不会被执行。利用这个特性，如果有多个条件判断，应当将计算过程较为复杂的表达式放在运算符的右侧。
- 在格式化输出时，使用`%t`来表示要输出的值为布尔型
- 使用`is`或`Is`开头的标识符命名布尔型，可以获得良好的代码阅读体验



### 位运算符

位运算符对整数在内存中的二进制位进行操作

**二元运算符**

| 运算符 | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| &      | 参与运算的两数各对应的二进位相与                             |
| \|     | 参与运算的两数各对应的二进位相或                             |
| ^      | 参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。 |
| &^     | （位清除运算）将指定位置上的值设置为0                        |

**位清空操作**：`a &^ b`，在a中，将一些位置的值设置为0，而这些位置由b确定。b用二进制表示，二进制为1的位置，就是a中要清空的位置。

```go
package main

import "fmt"

func main() {
	a := 12
	b := 4
	c := a &^ b
	fmt.Printf("a: %08b\n", a)
	fmt.Printf("b：%08b\n", b)
	fmt.Printf("c: %#v   二进制：%08b\n",c,c)

	/*输出：
	a: 00001100
	b：00000100
	c: 8   二进制：00001000
	*/
}
```



**一元运算符**

| 运算符 | 描述                                                |
| ------ | --------------------------------------------------- |
| ^      | 按位取反                                            |
| <<     | `bitP` 的位向左移动 n 位，右侧空白部分使用 0 填充； |
| \>\>   | `bitP` 的位向右移动 n 位，左侧空白部分使用 0 填充   |



**位左移常见实现存储单元的用例**

使用位左移与iota计数配合可优雅地实现存储单位的常量枚举：

```go
type ByteSize float64
const (
	_ = iota
	KB ByteSize = 1 << (10*iota)
	MB
	GB
	TB
	PB
	EB
	ZB
	YB
)
```



**在通讯中使用位左移表示标识的用例**

```go
type BitFlag int
const (
	Active BitFlag = 1 << iota
	Send 
	Receive
)

flag := Active | Send
```



### 赋值运算符

| 运算符 |                      描述                      |
| :----: | :--------------------------------------------: |
|   =    | 简单的赋值运算符，将一个表达式的值赋给一个左值 |
|   +=   |                  相加后再赋值                  |
|   -=   |                  相减后再赋值                  |
|   *=   |                  相乘后再赋值                  |
|   /=   |                  相除后再赋值                  |
|   %=   |                  求余后再赋值                  |
|  <<=   |                   左移后赋值                   |
|  >>=   |                   右移后赋值                   |
|   &=   |                  按位与后赋值                  |
|  \|=   |                  按位或后赋值                  |
|   ^=   |                 按位异或后赋值                 |



### 运算符与优先级

```
优先级 	运算符
 7 		^ !
 6 		* / % << >> & &^
 5 		+ - | ^
 4 		== != < <= >= >
 3 		<-
 2 		&&
 1 		||
```



















