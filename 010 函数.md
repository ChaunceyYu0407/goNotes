# 010 函数

## **命名规范**

==返回某个对象的函数或方法的名称一般都是使用名词，没有 `Get...` 之类的字符，如果是用于修改某个对象，则使用 `SetName`==。有必须要的话可以使用==大小写混合的方式==，如 MixedCaps 或 mixedCaps，==而不是使用下划线来分割多个名称==。



## 简介

Go ⾥⾯有三种类型的函数：

- 普通的带有名字的函数
- 匿名函数或者lambda函数
- ⽅法（结构体时介绍）

函数是指不属于任何结构体、类型的方法，也就是说函数是没有接收者的；而方法是有接收者的。



除了main()、init()函数外，其他所有类型的函数都可以有参数和返回值。

函数参数、返回值以及它们的类型被统称为函数签名。



Go不支持函数重载特性的主要原因是

- 函数重载需要进行多余的类型匹配影响性能；

没有重载意味着只是一个简单的函数调度，所以需要给不同的函数使⽤不同的名字，通常会根据函数的特征对函数进⾏命名。



## 函数

这是定义一个函数最简单的格式：

```
func functionName() {

}
```

你可以在括号 `()` 中写入 0 个或多个函数的参数（使用逗号 `,` 分隔），每个参数的名称后面必须紧跟着该参数的类型。

例如，

```go
func functionName(parameter_list) (return_value_list) {
	...
}
```

其中：

- parameter_list 的形式为 (param1 type1, param2 type2, …)
- return_value_list 的形式为 (ret1 type1, ret2 type2, …)

如果你的函数非常简短，你也可以将它们放在同一行：

```
func Sum(a, b int) int { return a + b }
```



## main函数

- main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数）。

- main 函数既没有参数，也没有返回类型（与 C 家族中的其它语言恰好相反）。



## 多值返回

Go语言支持函数方法的多值返回，也就是说定义的函数方法可以返回多个值

```
func main(){
	file, err :=os.Open("/usr/tmp")
	if err != nil{
		log.Fatal(err)
		return
	}
	fmt.Println(file)
}
```

```go
file, _:= os.Open("/usr/tmp")
```



## 可变参数

```
fmt.print("1","2","3")
```

可变参数的定义，在类型前面加上省略号...即可

```go
func intSUm3(a ...int){
//0个或多个int
//a其实是[]int
    ret := 0
    for _, num := range a{
        ret += num
    }
}

func print(a ...interface{}){
	for _,v:=range a{
		fmt.Print(v)
	}
	fmt.Println()
}
```

- 可变参数本质上是一个数组，所以我们像使用数组一样使用它，比如例子中的for range循环。
- 固定参数和可变参数同时出现，可变参数放在最后



## defer语句

go语言中`defer`语句会将其后面跟随的语句进行延迟处理，再defer归属的函数即将返回时，将延迟处理的语句按`defer定义的逆序进行`

也就是说先被`defer`的语句最后被执行，最后被`defer`的最先被执行



```go
func main(){
	fmt.Println("start")
	defer fmt.Println("1")
	defer fmt.Println("2")
	defer fmt.Println("3")
	fmt.Println("end")
}
//start
//end
//3
//2
//1
```

由于`defer`语句延迟调用的特性，所以该语句能够非常方便的处理资源释放问题，如资源清理，文件关闭，解锁，记录时间等。



## defer面试题

先给返回值赋值，defer函数执行，然后再return 

https://golangtc.com/t/5cd977eab17a82478bd85fa4

```go
func f1() int {
	x := 5
	defer func() {
		x++
	}()
	return x
}// reval = x   x++  return reval

func f2() (x int) {
	defer func() {
		x++
	}()
	return 5
}// x=5 rval=x  x++ return rval

func f3() (y int) {
	x := 5
	defer func() {
		x++
	}()
	return x
}

func f4() (x int) {
	defer func(x int) {
		x++
	}(x)
	return 5
}
func main() {
	fmt.Println(f1())
	fmt.Println(f2())
	fmt.Println(f3())
	fmt.Println(f4())
}

//5 6 5 5
```





## 匿名函数与闭包

匿名函数就是没有函数名的函数，多用于实现==回调函数和闭包==

匿名函数的定义格式

```go
func(parameter)(returnValue){
	body
}
```



立即执行函数，定义完之后，立即执行，加（）

```go
func main() {
	func(){
		fmt.Println("test")
	}()
	
	sayhi := func(){
		fmt.Println("hi")
	}
}
```





**闭包**

// 闭包 = 函数 + 外层变量的 引用

```go
func makeSuffixFunc(suffix string) func(string) string{
	return func(name string) string{
		if !strings.HasSuffix(name, suffix) {
			return name + suffix
		}
		return name
	}
}
func main(){
	r := makeSuffixFunc(".txt")
	ret := r("test")
	fmt.Println(ret)
}
```

使用闭包做文件后缀名检测





```go
func calc(base int) (func(int) int, func(int) int){
	add := func(i int) int{
		base += i
		return base
	}
	sub := func(i int) int{
		base -= i
		return base
	}
	return add, sub
}
```





## 内置函数

- close函数：主要用来关闭channel
- len
- new，分配内存，分配值类型，比如int, struct，返回的是指针
- make，分配内存，主要用来分配引用类型，比如chan,map,slice
- pannic和recover，用来做错误处理



GO语言中目前（1.12）是没有异常机制的，使用panic/recover模式来处理错误，panic可以在任何地方引发，但recover只有在defer调用的函数中有效，

```
func a(){
	fmt.Println("func a")
}

func b(){
	defer func(){
		err := recover()
		if err != nil {
			fmt.Println("recover in B")
		}
	}()
	panic("panic in B")
}
```

程序运行期间，funcB引发了panic导致程序崩溃，异常退出，这时，可以通过recover将程序恢复回来，继续往后执行

注意recover必须搭配defer使用，

defer一定要在引发panic的语句之前定义



注：Go语言种的函数没有默认参数









