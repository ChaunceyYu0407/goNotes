# 010 函数

## **命名规范**

==返回某个对象的函数或方法的名称一般都是使用名词，没有 `Get...` 之类的字符，如果是用于修改某个对象，则使用 `SetName`==。有必须要的话可以使用==大小写混合的方式==，如 MixedCaps 或 mixedCaps，==而不是使用下划线来分割多个名称==。



## 简介

Go ⾥⾯有三种类型的函数：

- 普通的带有名字的函数
- 匿名函数或者lambda函数
- ⽅法（结构体时介绍）

函数是指不属于任何结构体、类型的方法，也就是说函数是没有接收者的；而方法是有接收者的。



除了main()、init()函数外，其他所有类型的函数都可以有参数和返回值。

函数参数、返回值以及它们的类型被统称为函数签名。



Go不支持函数重载特性的主要原因是

- 函数重载需要进行多余的类型匹配影响性能

没有重载意味着只是一个简单的函数调度，所以需要给不同的函数使⽤不同的名字，通常会根据函数的特征对函数进⾏命名。



## 函数

这是定义一个函数最简单的格式：

```
func functionName() {

}
```



## 函数参数与返回值

可以在括号 `()` 中写入 0 个或多个函数的参数（使用逗号 `,` 分隔），每个参数的名称后面必须紧跟着该参数的类型。

例如，

```go
func functionName(parameter_list) (return_value_list) {
	...
}
```

其中：

- parameter_list 的形式为 (param1 type1, param2 type2, …)
- return_value_list 的形式为 (ret1 type1, ret2 type2, …)

如果你的函数非常简短，你也可以将它们放在同一行：

```go
func Sum(a, b int) int { return a + b }
```



### 按值传递、按引用传递

Go默认使用按值传递来传递参数，也就是传递参数的副本。

如果希望直接修改参数的值，需要将参数的地址传递给函数，这就是按引用传递。

其实，参数的地址也是一个变量，传递了这个变量的副本，==由这个变量的副本获取要修改的变量的地址==

在函数调用时，像切片、字典、接口、通道这样的引用类型都是默认使用引用传递（即使没有显式地指出指针）



### 命名返回值与非命名返回值

```go
package main

import "fmt"

var num int = 10
var numx2, numx3 int

func main() {
	numx2, numx3 = getX2AndX3(num)
	PrintValues()
	numx2, numx3 = getX2AndX3_2(num)
	PrintValues()
}

func PrintValues() {
    fmt.Printf("num = %d, 2x num = %d, 3x num = %d\n", num, numx2, numx3)
}

func getX2AndX3(input int) (int, int) {
	return 2 * input, 3 * input
}

func getX2AndX3_2(input int) (x2, x3 int){
	x2 = 2 * input
	x3 = 3 * input
	// return x2, x3
    return 
}
```

`getX2AndX3`是非命名返回值

`getX2AndX3_2`是命名返回值

- x2，x3会被初始化为相应的零值

- `return`或`return x2, x3`都可以

- 即使函数使用了命名返回值，依旧可以无视它而返回明确的值

  ```go
  func main() {
  	fmt.Println(testReturn(5))
  }
  
  func testReturn(input int) (x int) {
  	x = input * 2
  	return 5
  }
  //结果是5
  ```

> 尽量使用命名返回值，会使代码更清晰、更简短，同时更加容易读懂



## main函数

- main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数）。

- main 函数既没有参数，也没有返回类型（与 C 家族中的其它语言恰好相反）。



## 多值返回

Go语言支持函数方法的多值返回，也就是说定义的函数方法可以返回多个值

```
func main(){
	file, err :=os.Open("/usr/tmp")
	if err != nil{
		log.Fatal(err)
		return
	}
	fmt.Println(file)
}
```

```go
file, _:= os.Open("/usr/tmp")
```



## 可变参数

```
fmt.print("1","2","3")
```

可变参数的定义，在类型前面加上省略号...即可

```go
func intSUm3(a ...int){
//0个或多个int
//a其实是[]int
    ret := 0
    for _, num := range a{
        ret += num
    }
}

func print(a ...interface{}){
	for _,v:=range a{
		fmt.Print(v)
	}
	fmt.Println()
}
```

- 可变参数本质上是一个数组，所以我们像使用数组一样使用它，比如例子中的for range循环。
- 固定参数和可变参数同时出现，可变参数放在最后



> 通过...可将slice中的数据转变为函数中需要的可变参数

```go
func main() {
	strs := []string{"hi", "Joe", "Bar", "Anna"}
	f1(strs...)
}

func f1(strs ...string) {
	for i, str := range strs {
		fmt.Println(i, str)
	}
	f2(strs...)
	f3(strs)
}
func f2(strs ...string) {
	fmt.Printf("f2:%T\n", strs)
}
func f3(strs []string) {
	fmt.Printf("f3:%T\n", strs)
}
//0 hi
//1 Joe
//2 Bar
//3 Anna
//f2:[]string
//f3:[]string
```

> 如果变长参数的类型没有指定，可以使用空接口`interface{}`,结合反射与switch结构确定参数的类型

## defer语句

go语言中`defer`语句会将其后面跟随的语句进行延迟处理，在defer归属的函数即将返回时，将延迟处理的语句按`defer定义的逆序进行`

也就是说先被`defer`的语句最后被执行，最后被`defer`的最先被执行



```go
func main(){
	fmt.Println("start")
	defer fmt.Println("1")
	defer fmt.Println("2")
	defer fmt.Println("3")
	fmt.Println("end")
}
//start
//end
//3
//2
//1

func a() {
	i := 0
	defer fmt.Println(i)
	i++
	return
}
// 输出结果是0
```

由于`defer`语句延迟调用的特性，所以该语句能够非常方便的处理资源释放问题，如资源清理，文件关闭，解锁，记录时间等。

例如，

```go
package main

import "fmt"

func main() {
	doDBOperations()
}

func connectToDB() {
	fmt.Println("ok, connected to db")
}

func disconnectFromDB() {
	fmt.Println("ok, disconnected from db")
}

func doDBOperations() {
	connectToDB()
	fmt.Println("Defering the database disconnect.")
	defer disconnectFromDB() //function called here with defer
	fmt.Println("Doing some DB operations ...")
	fmt.Println("Oops! some crash or network error ...")
	fmt.Println("Returning from function here!")
	return //terminate the program
	// deferred function executed here just before actually returning, even if
	// there is a return or abnormal termination before
}
```



### defer语句与匿名函数

>  经典面试题
>
> 关键字defer经常配合匿名函数使用，它可以用于改变函数的命名返回值

先给返回值赋值，defer函数执行，然后再return 

https://golangtc.com/t/5cd977eab17a82478bd85fa4

```go
func f1() int {
	x := 5
	defer func() {
		x++
	}()
	return x
}// reval = x   x++  return reval

func f2() (x int) {
	defer func() {
		x++
	}()
	return 5
}// x=5 rval=x  x++ return rval

func f3() (y int) {
	x := 5
	defer func() {
		x++
	}()
	return x
}

func f4() (x int) {
	defer func(x int) {
		x++
	}(x)
	return 5
}
func main() {
	fmt.Println(f1())
	fmt.Println(f2())
	fmt.Println(f3())
	fmt.Println(f4())
}

//5 6 5 5
```



### defer与追踪

注意`defer` 后面跟着一个函数a，该函数的形参也是一个函数b，则会先计算函数b的结果，然后将函数b的结果作为函数a的形参

```go
func main() {
	testDefer()
}

func testDefer() {
	defer fmt.Println(testDeferInnerFunc())
	fmt.Println("Beginning")
}
func testDeferInnerFunc() (res string) {
	fmt.Println("Hi, this is the inner func.")
	return "Ending"
}
```



```go
package main

import "fmt"

func trace(s string) string {
	fmt.Println("entering:", s)
	return s
}

func untrace(s string) {
	fmt.Println("leaving:", s)
}

func a() {
	defer untrace(trace("a"))
	fmt.Println("in a")
}

func b() {
	defer untrace(trace("b"))
	fmt.Println("in b")
	a()
}

func main() {
	b()
}
//entering: b
//in b
//entering: a
//in a
//leaving: a
//leaving: b
```



### 记录函数参数与返回值

```go
package main

import (
	"io"
	"log"
)

func func1(s string) (n int, err error) {
	defer func() {
		log.Printf("func1(%q) = %d, %v", s, n, err)
	}()
	return 7, io.EOF
}

func main() {
	func1("Go")
}
//Output: 2011/10/04 10:46:11 func1("Go") = 7, EOF
```







## 匿名函数与闭包

### 匿名函数

匿名函数就是没有函数名的函数，多用于实现==回调函数和闭包==

匿名函数的定义格式

```go
func(parameter)(returnValue){
	body
}
```



这样一个函数不能够独立存在，编译器会返回错误`non-declaration statement outside function`

两种方式：

- 保存函数的地址到变量中
- 直接对匿名函数进行调用

立即执行函数，定义完之后，立即执行，加（）

```go
func main() {
    //直接调用
	func(){
		fmt.Println("test")
	}()
	//保存到变量中
	sayhi := func(){
		fmt.Println("hi")
	}
}
```



### 闭包

// 闭包 = 函数 + 外层变量的 引用

- 匿名函数同样被称之为闭包（函数式语言的术语）：它们被允许调用定义在其他环境下的变量。闭包可使得某个函数捕捉到一些外部状态，例如：函数被创建时的状态。

- 这种状态（作用域内的变量）都被共享到闭包的环境中，因此这些变量可以在闭包中被操作，直到被销毁。

### 闭包的应用

使用闭包做文件后缀名检测

```go
func makeSuffixFunc(suffix string) func(string) string{
	return func(name string) string{
		if !strings.HasSuffix(name, suffix) {
			return name + suffix
		}
		return name
	}
}
func main(){
	r := makeSuffixFunc(".txt")
	ret := r("test")
	fmt.Println(ret)
}
```



```go
func calc(base int) (func(int) int, func(int) int){
	add := func(i int) int{
		base += i
		return base
	}
	sub := func(i int) int{
		base -= i
		return base
	}
	return add, sub
}
```

### 将函数作为返回值

```go
func main() {
	f := adder()
	fmt.Println(f(1))
	fmt.Println(f(20))
	fmt.Println(f(300))
}

// adder函数return f(int) int函数
func adder() func(int) int {
	var x int
	return func(delta int) int {
		x += delta
		return x
	}
}
//1
//21
//321
```

三次调用函数f的过程中adder中变量的delta的值分别为1,20,300

而在多次调用中，变量x的值是被保留的。闭包函数保存并积累其中的变量的值，不管外部函数退出与否，它都能继续操作外部函数中的局部变量。





## 内置函数

- close函数：主要用来关闭channel
- len函数：len用于返回某个类型的长度或数量（字符串、数组、切片、map和管道）
- cap函数：cap是容量的意思，用于返回某个类型的最大容量（只能用于切片和map)
- new，分配内存，分配值类型，比如int, struct，返回的是指针
- make，分配内存，主要用来分配引用类型，比如chan,map,slice
- pannic和recover，用来做错误处理
- copy、append：用于复制和连接切片
- print、println：底层打印函数，在部署环境中建议使用fmt包
- complex、real、imag：用于创建和操作复数



GO语言中目前（1.12）是没有异常机制的，使用panic/recover模式来处理错误，panic可以在任何地方引发，但recover只有在defer调用的函数中有效，

```go
func a(){
	fmt.Println("func a")
}

func b(){
	defer func(){
		err := recover()
		if err != nil {
			fmt.Println("recover in B")
		}
	}()
	panic("panic in B")
}
```

- 程序运行期间，funcB引发了panic导致程序崩溃，异常退出，这时，可以通过recover将程序恢复回来，继续往后执行


- 注意recover必须搭配defer使用，


- defer一定要在引发panic的语句之前定义




> Go语言中的函数没有默认参数



## 函数作为参数

函数可以作为其他函数的参数进行传递，然后在其他函数内调用执行，一般称之为回调。

下面是将一个函数作为参数的简单例子

```go
func main() {
	callback(1, 2, myadd)
}
func myadd(x int, y int) {
	c := x + y
	fmt.Println(c)
}
func callback(x, y int, f func(int, int)) {
	f(x, y)
}
```







注：

- 函数值之间可以相互比较，如果它们引用的是相同的函数或者都是 nil 的话，则认为它们是相同的函数。
- 函数不能在其它函数里面声明（不能嵌套），不过可以通过使用匿名函数来破除这个限制。
- 目前 Go 没有泛型（generic）的概念，也就是说它不支持那种支持多种类型的函数。不过在大部分情况下可以通过接口（interface），特别是==空接口与类型选择==与或者通过使用==反射==来实现相似的功能。使用这些技术将导致代码更为复杂、性能更为低下，所以在非常注意性能的的场合，最好是为每一个类型单独创建一个函数，而且代码可读性更强。
- ==可以返回其他函数的函数和接收其他函数作为参数的函数均被称为高阶函数，这是函数式语言的特点。==显然，Go语言具有一些函数式语言的特性。
- 闭包在Go语言中非常常见，常用于==go routine 和管道操作==



练习题1：不使用递归但使用闭包编写斐波那契数列程序

```go
func main() {
	f := makeFi()
	for i := 0; i < 10; i++ {
		fmt.Println(f(i))
	}
}

func makeFi() func(int) int {
	pre1 := 0
	pre2 := 1
	return func(index int) int {
		if index == 0 {
			return 0
		} else if index == 1 {
			return 1
		}
		sum := pre1 + pre2
		pre1, pre2 = pre2, sum
		return sum
	}
}
```

> 有个缺陷，就是只能顺序输出，中间跳过一个就不对了
>
> 但是按照题目的意思，应该就是这样写代码



练习题2：一个返回值为另一个函数的函数可以被称之为工厂函数，这在需要创建一系列相似的函数时非常有用。书写一个工厂函数而不是针对每种情况都书写一个函数。

动态返回追加后缀的函数：

```go
func MakeAddSuffix(suffix string) func(string) string {
	return func(name string) string {
		if !strings.HasSuffix(name, suffix) {
		 	return name + suffix
		}
		return name
	}
}

addBmp := MakeAddSuffix(".bmp")
addJpeg := MakeAddSuffix(".jpeg")
addBmp("file") //file.bmp
addJpeg("file") //file.jpeg
```

