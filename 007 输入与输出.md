# 007 输入与输出

## 输出

```go
Print:   输出到控制台(不接受任何格式化，它等价于对每一个操作数都应用 %v)
         fmt.Print(str)
Println: 输出到控制台并换行
         fmt.Println(tmp)
Printf : 只可以打印出格式化的字符串。只可以直接输出字符串类型的变量
         fmt.Printf("%d",a)
Sprintf：格式化并返回一个字符串而不带任何输出。
         s := fmt.Sprintf("a %s", "string") fmt.Printf(s)
Fprintf：来格式化并输出到 io.Writers 而不是 os.Stdout。
         fmt.Fprintf(os.Stderr, “an %s\n”, “error”)
```

**Printf 格式化输出**

- 通用占位符

  ```go
  %v    值的默认格式。
  %+v   添加字段名(如结构体)
  %#v　 相应值的Go语法表示 
  %T    相应值的类型的Go语法表示 
  %%    字面上的百分号，并非值的占位符
  ```

- 布尔值

  ```
  %t   true 或 false
  ```

- 整数值

  ```
  %b     二进制表示 
  %c     相应Unicode码点所表示的字符 
  %d     十进制表示 
  %o     八进制表示 
  %q     单引号围绕的字符字面值，由Go语法安全地转义 
  %x     十六进制表示，字母形式为小写 a-f 
  %X     十六进制表示，字母形式为大写 A-F 
  %U     Unicode格式：U+1234，等同于 "U+%04X"
  ```

- 浮点数及复数

  ```
  %b     无小数部分的，指数为二的幂的科学计数法，与 strconv.FormatFloat中的 'b' 转换格式一致。例如 -123456p-78 
  %e     科学计数法，例如 -1234.456e+78 
  %E     科学计数法，例如 -1234.456E+78 
  %f     有小数点而无指数，例如 123.456 
  %g     根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出 
  %G     根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出
  ```

- 宽度和精度

  ```
  %f:      default width, default precision 
  %9f      width 9, default precision 
  %.2f     default width, precision 2 
  %9.2f    width 9, precision 2 
  %9.f     width 9, precision 0
  ```

  - 宽度和精度格式化控制的是unicode码值的数量。两者任意一个或者两个都可以使用`*`代替，此时它们的值将被替换为对应的参数
  - 对大多数类型的值，宽度是输出字符数目的最小数量，如果必要，会用空格填充。（字符串没有宽度）
  - 对于字符串string，精度是输出字符串数目的最大数量，如果必要，会截段字符串。

  - 对于整数 int，宽度和精度都设置输出总长度，采用精度时表示右对齐并使用 0 填充，而宽度默认使用空格填充。
  - 对于浮点数 float，宽度设置输出总长度；精度设置小数部分长度（如果有的话），除了 %g 和 %G，此时精度设置总的数字个数。%e 和 %f 的默认精度是 6，%g 的默认精度是可以将该值区分出来需要的最小数字个数。
  - 对于复数，宽度和精度会分别用于实部和虚部， 结果用小括号包括， 因此 %f 用于 1.2+3.4i 输出 （1.200000+3.400000）

- 字符串和bytes的slice表示

  ```
  %s     字符串或切片的无解译字节 
  %q     双引号围绕的字符串，由Go语法安全地转义 
  %x     十六进制，小写字母，每字节两个字符 
  %X     十六进制，大写字母，每字节两个字符
  ```

- 指针

  ```
  %p     十六进制表示，前缀 0x
  ```

- %v：值的默认格式

  ```
  bool:                    %t 
  int, int8 etc.:          %d 
  uint, uint8 etc.:        %d, %x if printed with %#v
  float32, complex64, etc: %g
  string:                  %s
  chan:                    %p 
  pointer:                 %p
  ```

  一般来说都可以用%v进行替代，但是不推荐使用

- 复合对象

  ```
  struct:            {field0 field1 ...} 
  array, slice:      [elem0 elem1 ...] 
  maps:              map[key1:value1 key2:value2] 
  pointer to above:  &{}, &[], &map[]
  ```

https://kuricat.com/gist/golang-fmtprintf-unswf



## 输入

```
Scan、Scanf 和 Scanln        从os.Stdin 中读取；
Fscan、Fscanf 和 Fscanln     从指定的 io.Reader 中读取；
Sscan、Sscanf 和 Sscanln     从实参字符串中读取。

Scanln、Fscanln 和 Sscanln   在换行符处停止扫描，且需要条目紧随换行符之后；
Scanf、Fscanf 和 Sscanf      需要输入换行符来匹配格式中的换行符；其它函数则将换行符视为空格。
```



Scanf、Fscanf、Sscanf 根据格式字符串解析实参，类似于Printf

在输入Scanf中，宽度可以理解成输入的文本（％5s表示输入５个字符），而Scanf没有精度这种说法（没有%5.2f，只有 %5f）

```go
func main() {
	op := -1
	fmt.Scan(&op)
	switch op {
	case 1:
		fmt.Println(op)
	case 2:
		fmt.Println(op)
	case 3:
		fmt.Println(op)
	case 4:
		fmt.Println(op)
	}
	fmt.Scanf("name:%s age:%d married:%t\n", &name, &age, &married)
}
```

Scan类：通过空白符分割(包括回车)

Scanf类：严格按照这个输入模式，遇到回车时（format里有）匹配结束

Scanln类：遇到回车就结束