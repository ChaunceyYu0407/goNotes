# 010 控制结构

到目前为止，我们看到的 Go 程序都是从 main() 函数开始执行，然后按顺序执行该函数体中的代码。但我们经常会需要只有在满足一些特定情况时才执行某些代码，也就是说在代码里进行条件判断。

针对这种需求，Go 提供了下面这些==条件结构和分支结构==：

- if-else 结构
- switch 结构
- select 结构，用于 channel 的选择



可以使用==迭代或循环结构==来重复执行一次或多次某段代码（任务）：

- for (range) 结构



一些如 `break` 和 `continue` 这样的关键字可以用于中途改变循环的状态。

此外，你还可以使用 `return` 来结束某个函数的执行，或使用 `goto` 和标签来调整程序的执行位置。

Go 完全省略了 `if`、`switch` 和 `for` 结构中条件语句两侧的括号，相比 Java、C++ 和 C# 中减少了很多视觉混乱的因素，同时也使你的代码更加简洁。



##  if-else 结构

**习惯用法一**

```go
 var prompt = "Enter a digit, e.g. 3 "+ "or %s to quit."
 
 func init() {
 	if runtime.GOOS == "windows" {
 		prompt = fmt.Sprintf(prompt, "Ctrl+Z, Enter")		
 	} else { //Unix-like
 		prompt = fmt.Sprintf(prompt, "Ctrl+D")
 	}
 }
```



**习惯用法二**

if 可以包含一个初始化语句（如：给一个变量赋值）。

例如：

```go
if val := 10; val > max {
	// do something
}
```

- 使用简短方式 `:=` 声明的变量的作用域只存在于 if 结构中（在 if 结构的大括号之间，如果使用 if-else 结构则在 else 代码块中变量也会存在）。

- 如果变量在 if 结构之前就已经存在，那么在 if 结构中，该变量原来的值会被隐藏。

下面的代码片段展示了如何通过在初始化语句中获取函数 `process()` 的返回值，并在条件语句中作为判定条件来决定是否执行 if 结构中的代码：

```go
if value := process(data); value > max {
	...
}
```



## 测试多返回值函数的错误

Go 语言的函数经常使用两个返回值来表示执行是否成功：返回某个值以及 true 表示成功；返回零值（或 nil）和 false 表示失败（第 4.4 节）。当不使用 true 或 false 的时候，也可以使用一个 error 类型的变量来代替作为第二个返回值：成功执行的话，error 的值为 nil，否则就会包含相应的错误信息（Go 语言中的错误类型为 error: `var err error`）。这样一来，就很明显需要用一个 if 语句来测试执行结果；由于其符号的原因，这样的形式又称之为 ==comma,ok 模式（pattern）==。



```go
package main

import (
	"fmt"
	"strconv"
)

func main() {
	var orig string = "ABC"
	var newS string
	
	fmt.Printf("The size of ints is: %d\n", strconv.IntSize)	  
	an, err := strconv.Atoi(orig)
	if err != nil {
		fmt.Printf("orig %s is not an integer - exiting with error\n", orig)
		return
	} 
    
	fmt.Printf("The integer is %d\n", an)
	an = an + 5
	newS = strconv.Itoa(an)
	fmt.Printf("The new string is: %s\n", newS)
}
```

这是测试 err 变量是否包含一个真正的错误（`if err != nil`）的习惯用法。

如果确实存在错误，则会打印相应的错误信息然后通过 return 提前结束函数的执行。我们还可以使用携带返回值的 return 形式，例如 `return err`。这样一来，函数的调用者就可以检查函数执行过程中是否存在错误了。



**习惯用法一**

```go
value, err := pack1.Function1(param1)
if err != nil {
	fmt.Printf("An error occured in pack1.Function1 with parameter %v", param1)
	return err
}
```



**习惯用法二**

```go
if err != nil {
	fmt.Printf("Program stopping with error %v", err)
	os.Exit(1)
}
```



**习惯用法三**

将错误的获取语句放置在if语句的初始化部分

```go
if err := file.Chmod(0664); err != nil {
	fmt.Println(err)
	return err
}
```



**习惯用法四**

将`ok-pattern`放置在if语句的初始化部分

```go
if value, ok := readData(); ok {
    //do something
}
```



将字符串转换为整数时，且确定转换一定能够成功时，可以将 `Atoi` 函数进行一层忽略错误的封装：

```
func atoi (s string) (n int) {
	n, _ = strconv.Atoi(s)
	return
}
```



实际上，`fmt` 包最简单的打印函数也有 2 个返回值：

```
count, err := fmt.Println(x) // number of bytes printed, nil or 0, error
```

当打印到控制台时，可以将该函数返回的错误忽略；但当输出到文件流、网络流等具有不确定因素的输出对象时，应该始终检查是否有错误发生。



## switch结构

相比较 C 和 Java 等其它语言而言，Go 语言中的 switch 结构使用上更加灵活。它接受任意形式的表达式：

```
switch var1 {
	case val1:
		...
	case val2:
		...
	default:
		...
}
```

- `var1`,`var2`必须是相同类型的值或计算结果为相同类型的表达式
- 可同时测试多个可能符合条件的值，用逗号分割

- Go 语言使用快速的查找算法来测试 switch 条件与 case 分支的匹配情况，直到算法匹配到某个 case 或者进入 default 条件为止。

- 一旦成功地匹配到某个分支，在执行完相应代码后就会退出整个 switch 代码块，不需要使用break。如果在执行完每个分支的代码后，希望继续执行后续分支的代码，可以使用 `fallthrough` 关键字。

- 在 `case ...:` 语句之后，您不需要使用花括号将多行语句括起来，但您可以在分支中进行任意形式的编码。当代码块只有一行时，可以直接放置在 `case` 语句之后。



**习惯用法一**

```
package main

import "fmt"

func main() {
	var num1 int = 100

	switch num1 {
	case 98, 99:
		fmt.Println("It's equal to 98")
	case 100: 
		fmt.Println("It's equal to 100")
	default:
		fmt.Println("It's not equal to 98 or 100")
	}
}
```



**习惯用法二**

switch 语句的第二种形式是不提供任何被判断的值（实际上默认为判断是否为 true），然后在每个 case 分支中进行测试不同的条件。

当任一分支的测试结果为 true 时，该分支的代码会被执行。这看起来非常像链式的 `if-else` 语句，但是在测试条件非常多的情况下，提供了可读性更好的书写方式。

例如：

```
package main

import "fmt"

func main() {
	var num1 int = 7

	switch {
	    case num1 < 0:
		    fmt.Println("Number is negative")
	    case num1 > 0 && num1 < 10:
		    fmt.Println("Number is between 0 and 10")
	    default:
		    fmt.Println("Number is 10 or greater")
	}
}
```



**习惯用法三**

switch 语句的第三种形式是包含一个初始化语句，这种形式可以非常优雅地进行条件判断。在下面这个代码片段中，变量 a 和 b 被平行初始化，然后作为判断条件：

```
switch a, b := x[i], y[j]; {
	case a < b: t = -1
	case a == b: t = 0
	case a > b: t = 1
}
```



> switch 语句还可以被用于 type-switch（参见后续的反射章节）来判断某个 interface 变量中实际存储的变量类型。



## for 结构

> 其它许多语言中也没有发现和 do while 完全对等的 for 结构，可能是因为这种需求并不是那么强烈。

**习惯用法一 基于计数器的迭代**

```
package main

import "fmt"

func main() {
	for i := 0; i < 5; i++ {
		fmt.Printf("This is the %d iteration\n", i)
	}
}
```

> 特别注意, ==永远不要在循环体内修改计数器，这在任何语言中都是非常差的实践！==



得益于 Go 语言具有的平行赋值的特性,==可以在循环中同时使用多个计数器：==

```
for i, j := 0, N; i < j; i, j = i+1, j-1 {}
```



**习惯用法二 基于条件判断的迭代**

for 结构的第二种形式是没有头部的条件判断迭代（类似其它语言中的 while 循环），基本形式为：`for 条件语句 {}`。

```
package main

import "fmt"

func main() {
	var i int = 5

	for i >= 0 {
		i = i - 1
		fmt.Printf("The variable i is now: %d\n", i)
	}
}
```



**习惯用法三 无限循环**

条件语句是可以被省略的，如 `i:=0; ; i++` 或 `for { }` 或 `for ;; { }`（`;;` 会在使用 gofmt 时被移除）：这些循环的本质就是无限循环。最后一个形式也可以被改写为 `for true { }`，但一般情况下都会直接写 `for { }`。

如果 for 循环的头部没有条件语句，那么就会认为条件永远为 true，因此循环体内必须有相关的条件判断以确保会在某个时刻退出循环。想要直接退出循环体，可以使用 break 语句或 return 语句直接返回。

无限循环的经典应用是服务器，用于不断等待和接受新的请求。



**习惯用法四 for-range**

这是 Go 特有的一种的迭代结构，它可以迭代任何一个集合（包括数组和 map等）。一般形式为：`for ix, val := range coll { }`。

==要注意的是，`val` 始终为集合中对应索引的值拷贝，因此它一般只具有只读性质，对它所做的任何修改都不会影响到集合中原有的值==

**如果 val 为指针，则会产生指针的拷贝，依旧可以修改集合中的原值**。



## break 与 continue

一个 break 的作用范围为该==语句出现后的最内部的结构==，它可以被用于任何形式的 for 循环（计数器、条件判断等）。==但在 switch 或 select 语句中，break 语句的作用结果是跳过整个代码块，执行后续的代码。==

下面的示例中包含了嵌套的循环体（for4.go），break 只会退出最内层的循环：

```
package main

func main() {
	for i:=0; i<3; i++ {
		for j:=0; j<10; j++ {
			if j>5 {
			    break   
			}
			print(j)
		}
		print("  ")
	}
}

//012345 012345 012345
```



关键字 continue 忽略剩余的循环体而直接进入下一次循环的过程，但不是无条件执行下一次循环，执行之前依旧需要满足循环的判断条件。

```
package main

func main() {
	for i := 0; i < 10; i++ {
		if i == 5 {
			continue
		}
		print(i)
		print(" ")
	}
}
//0 1 2 3 4 6 7 8 9
```

> 另外，关键字 continue 只能被用于 for 循环中。



## label 与 goto

for、switch 或 select 语句都可以配合标签（label）形式的标识符使用，即某一行第一个以冒号（`:`）结尾的单词（gofmt 会将后续代码自动移至下一行）。



（标签的名称是大小写敏感的，为了提升可读性，一般建议使用全部大写字母）

```
package main

import "fmt"

func main() {

LABEL1:
	for i := 0; i <= 5; i++ {
		for j := 0; j <= 5; j++ {
			if j == 4 {
				continue LABEL1
			}
			fmt.Printf("i is: %d, and j is: %d\n", i, j)
		}
	}

}
//i is: 0, and j is: 0
//i is: 0, and j is: 1
//i is: 0, and j is: 2
//i is: 0, and j is: 3
//i is: 1, and j is: 0
//i is: 1, and j is: 1
//i is: 1, and j is: 2
//i is: 1, and j is: 3
//..
```

本例中，continue 语句指向 LABEL1，当执行到该语句的时候，就会跳转到 LABEL1 标签的位置。可以看到当 j\==4 和 j\==5 的时候，没有任何输出。

标签的作用对象为外部循环，因此 i 会直接变成下一个循环的值，而此时 j 的值就被重设为 0，即它的初始值。如果将 continue 改为 break，则不会只退出内层循环，而是直接退出外层循环了。



另外，还可以使用 goto 语句和标签配合使用来模拟循环。

```
package main

func main() {
	i:=0
	HERE:
		print(i)
		i++
		if i==5 {
			return
		}
		goto HERE
}
//01234
```

使用逆向的 goto 会很快导致意大利面条式的代码，所以不应当使用而选择更好的替代方案。

**特别注意** 

- 使用标签和 goto 语句是不被鼓励的：它们会很快导致非常糟糕的程序设计，而且总有更加可读的替代方案来实现相同的需求。

- 一个建议使用 goto 语句，使用 goto 来跳出无限读取循环并关闭相应的客户端链接。

  > 在后续会提到这个

- 定义但未使用标签会导致编译错误：`label … defined and not used`。

- 如果您必须使用 goto，应当只使用正序的标签（标签位于 goto 语句之后），但注意标签和 goto 语句之间不能出现定义新变量的语句，否则会导致编译失败。

```
// compile error goto2.go:8: goto TARGET jumps over declaration of b at goto2.go:8
package main

import "fmt"

func main() {
		a := 1
		goto TARGET // compile error
		b := 9
	TARGET:  
		b += a
		fmt.Printf("a is %v *** b is %v", a, b)
}
```