# 006 常量与变量

命名规则遵循骆驼命名法，即首个单词小写，每个新单词的首字母大写，例如：`numShips` 和 `startDate`，若希望能够被外部包所使用，则需要将首个单词的首字母也大写。



## 常量

### 声明格式

**常量声明标准格式**

- 相对于变量，常量是恒定不变的值，多用于定义程序运行期间不会改变的那些值。 

- 常量在定义的时候**必须赋值**。
- 存储在常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。

```go
//隐式类型定义
const pi = 3.1415
const e = 2.7182
//显示类型定义
const b string = "abc"
```

- 换句话说，未定义类型的常量会在必要时刻根据上下文来获得相关类型。





**常量批量声明**

```go
const (
    pi = 3.1415
    e = 2.7182
)

```

const同时声明多个常量时，如果省略了值则表示和上面一行的值相同。 例如：

```go
const (
    n1 = 100
    n2
    n3
)

```



**常量支持并行赋值**

```go
const (
	Monday, Tuesday, Wednesday = 1, 2, 3
	Thursday, Friday, Saturday = 4, 5, 6
)
```



注意事项：

- 数字型的常量是没有大小和符号的，并且可以使用任何精度而不会导致溢出

  ```go
  const Ln2 = 0.693147180559945309417232121458\
  			176568075500134360255254120680009
  const Log2E = 1/Ln2 // this is a precise reciprocal
  const Billion = 1e9 // float constant
  const hardEight = (1 << 100) >> 97
  ```

  - 反斜杠`\`可以在常量表达式中作为多行的连接符使用
  - 数字型的常量无需担心类型转换问题，它们都是非常理想的数字
  - 当常量赋值给一个精度过小的数字型变量时，可能会因为无法正确表示而导致溢出，会在编译期间引发错误

- 不可以用自定义的函数给常量赋值，但内置函数可以，例如`len()`

  ```go
  const testConst = "test"
  const c1 = len(testConst)
  //testConst 必须也是常量，否则编译无法通过
  //由于常量的限制，所以无法len([]int{2,3,4})这样也不行
  const c2 = getNumber()
  //getNumber() used as value
  func main() {
  	fmt.Println(length)
  }
  ```

- 常量用作枚举

  ```go
  const (
  	UnKnown = 0
  	Female = 1
  	Male = 2
  )
  ```

  - 常量用作枚举时，往往和关键字iota结合



### iota关键字

- `iota`是go语言的常量计数器，只能在常量的表达式中使用。

- `iota`在const关键字出现时将被重置为0。

- const中每新增一行常量声明将使`iota`计数一次(iota可理解为const语句块中的行索引)。 使用iota能简化定义，在定义枚举时很有用。



**几个常见的`iota`示例:**

使用`_`跳过某些值

```go
const (
		n1 = iota //0
		n2        //1
		_
		n4        //3
	)

```



`iota`声明中间插队

```go
const (
		n1 = iota //0
		n2 = 100  //100
		n3 = iota //2
		n4        //3
	)
const n5 = iota //0

```



定义数量级 

```go
const (
		_  = iota
		KB = 1 << (10 * iota)
		MB = 1 << (10 * iota)
		GB = 1 << (10 * iota)
		TB = 1 << (10 * iota)
		PB = 1 << (10 * iota)
	)

```



多个`iota`定义在一行

```go
const (
		a, b = iota + 1, iota + 2 //1,2
		c, d                      //2,3
		e, f                      //3,4
	)

```



```go
// 赋值一个常量时，之后没赋值的常量都会应用上一行的赋值表达式
const (
	a = iota  // a = 0
	b         // b = 1
	c         // c = 2
	d = 5     // d = 5   
	e         // e = 5
)
```



## 变量

**Go是静态类型语言不同于php和python**

- 变量的意义：分配内存，并命名，方便操作与使用
- 变量必须先声明后使用
- Go语言在声明变量的时候，会自动对变量对应的内存区域进行初始化操作。每个变量会被初始化成其类型的默认值，例如： 整型和浮点型变量的默认值为`0`。 字符串变量的默认值为`空字符串`。 布尔型变量默认为`false`。 切片、函数、指针变量的默认为`nil`。



### 变量的作用域

- 一个变量（常量、类型或函数）在程序中都有一定的作用范围，称之为作用域。

- ==如果一个变量在函数体外声明，则被认为是全局变量，可以在整个包==（被导出后可以在外部包）使用。

- 在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，参数和返回值变量也是局部变量。一般情况下，局部变量的作用域可以通过代码块（用大括号括起来的部分）判断。

- 可以在某个代码块的内层代码块中使用相同名称的变量，则此时外部的同名变量将会暂时隐藏。



### 声明格式

> 需要注意的是，Go 和许多编程语言不同，它在声明变量时将变量的类型放在变量的名称之后。Go 为什么要选择这么做呢？
>
> 首先，它是为了避免像 C 语言中那样含糊不清的声明形式，例如：`int* a, b;`。在这个例子中，只有 a 是指针而 b 不是。如果你想要这两个变量都是指针，则需要将它们分开书写。
>
> 其次，这种语法能够按照从左至右的顺序阅读，使得代码更加容易理解

**标准声明格式**

```go
var name string		
```



**批量声明格式**

```go
var(
	name string  //""
	age int      //0
	isOk bool    //false
)
// 这种因式分解关键字的写法一般用于声明全局变量
```



### 初始化

**可在声明变量的时候为其指定初始值。变量初始化的标准格式如下：**

```go
var 变量名 类型 = 表达式
```

举个例子：

```go
var name string = "Q1mi"
var age int = 18
```

**一次初始化多个变量**

```go
var name,age = "QImi",20
```



### 类型推导

有时会将变量的类型省略，这个时候编译器会根据等号右边的值来推导变量的类型完成初始化

```go
// 变量类型在编译时实现自动推断
var name = "Qimi"
var age = 18

// 变量类型在运行时实现自动推断
var (
	HOME = os.Getenv("HOME")
	USER = os.Getenv("USER")
	GOROOT = os.Getenv("GOROOT")
)
```



### 短变量声明

> 这是使用变量的首选形式，但是它只能被用在函数体内，而不可以用于全局变量的声明与赋值。使用操作符 `:=` 可以高效地创建一个新的变量，称之为初始化声明。

**在函数内部**，可以使用更简略的 := 方式声明并初始化变量

```go
package main

import "fmt"

var m=100

func main(){
    m := 10   //局部变量
    n := 20
    fmt.Println(m,n)
}

```



注意：

- 局部变量声明之后必须使用，单纯的赋值也是不够的
- 全局变量允许声明但不使用



### 匿名变量

在使用多重赋值时，如果想要忽略某个值，可以使用`匿名变量（anonymous variable）`。

匿名变量用一个下划线`_`表示，例如：

```go
func foo() (int, string) {
	return 10, "Q1mi"
}
func main() {
	x, _ := foo()
	_, y := foo()
	fmt.Println("x=", x)
	fmt.Println("y=", y)
}

```

匿名变量不占用命名空间，不会分配内存，所以匿名变量之间不存在重复声明。

 (在`Lua`等编程语言里，匿名变量也被叫做哑元变量。)



### init函数中的变量初始化

- 变量除了可以在全局声明中初始化，也可以在 init 函数中初始化。

- 这是一类非常特殊的函数，它不能够被人为调用，而是在每个包完成初始化后自动执行，并且执行优先级比 main 函数高。

- 每个源文件都只能包含一个 init 函数。初始化总是以单线程执行，并且按照包的依赖关系顺序执行。

- 一个可能的用途是在开始执行程序之前对数据进行检验或修复，以保证程序状态的正确性。

```go
package trans

import "math"

var Pi float64

func init() {
   Pi = 4 * math.Atan(1) // init() function computes Pi
}
```



```go
package main

import (
   "fmt"
   "./trans"
)

var twoPi = 2 * trans.Pi

func main() {
   fmt.Printf("2*Pi = %g\n", twoPi) // 2*Pi = 6.283185307179586
}
```



init 函数也经常被用在当一个程序开始之前调用后台执行的 goroutine，如下面这个例子当中的 `backend()`：

```go
func init() {
   // setup preparations
   go backend()
}
```