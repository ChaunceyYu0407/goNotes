# 008 指针、值类型与引用类型

## 指针

不像 Java 和 .NET，Go 语言为程序员提供了控制数据结构的指针的能力，==但是，你不能进行指针运算。==

通过给予程序员基本内存布局，Go 语言允许控制特定集合的数据结构、分配的数量以及内存访问模式，这些对构建运行良好的系统是非常重要的。



> 这里简单阐述一下我对指针的理解
>
> 声明变量的过程就是向系统申请内存的过程。如果在程序中声明了一个变量，那么操作系统会分配一块内存，此后就可以通过变量名在这块内存中存储、修改值。
>
> 这一块内存在操作系统中是有地址的，可以通过取地址&符来获得这个地址，把这个地址信息存在另一个变量中，这个变量就叫做指针。



- 程序在内存中存储它的值，每个内存块（或字）有一个地址，通常用十六进制数表示，如：`0x6b0820` 或 `0xf84001d7f0`。

- Go 语言的取地址符是 `&`，放到一个变量前使用就会返回相应变量的内存地址。
- 一个指针变量可以指向任何一个值的内存地址**。它指向那个值的内存地址，在 32 位机器上占用 4 个字节，在 64 位机器上占用 8 个字节，并且与它所指向的值的大小无关。
- ==在指针类型前面加上 * 号（前缀）来获取指针所指向的内容，这里的 * 号是一个类型更改器。使用一个指针引用一个值被称为间接引用。==
- 当一个指针被定义后没有分配到任何变量时，它的值为 `nil`。
- 一个指针变量通常缩写为 `ptr`。



==符号 * 可以放在一个指针前，如 `*intP`，那么它将得到这个指针指向地址上所存储的值；这被称为反引用（或者内容或者间接引用）操作符；另一种说法是指针转移。==

```go
package main
import "fmt"
func main() {
	var i1 = 5
	fmt.Printf("An integer: %d, its location in memory: %p\n", i1, &i1)
	var intP *int
	intP = &i1
	fmt.Printf("The value at memory location %p is %d\n", intP, *intP)
}
//An integer: 5, its location in memory: 0x24f0820
//The value at memory location 0x24f0820 is 5
```

可以用下图来表示内存使用的情况：

[![img](4.1.assets/4.9_fig4.4.png)](https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/images/4.9_fig4.4.png?raw=true)





展示了分配一个新的值给 *p 并且更改这个变量自己的值（这里是一个字符串）。

```go
package main
import "fmt"
func main() {
	s := "good bye"
	var p *string = &s
	*p = "ciao"
	fmt.Printf("Here is the pointer p: %p\n", p) // prints address
	fmt.Printf("Here is the string *p: %s\n", *p) // prints string
	fmt.Printf("Here is the string s: %s\n", s) // prints same string
}
//Here is the pointer p: 0x2540820
//Here is the string *p: ciao
//Here is the string s: ciao
```

通过对 *p 赋另一个值来更改“对象”，这样 s 也会随之更改。

内存示意图如下：

[![img](4.1.assets/4.9_fig4.5.png)





**注意事项1**

你不能获取字面量或常量的地址，例如：

```
const i = 5
ptr := &i //error: cannot take the address of i
ptr2 := &10 //error: cannot take the address of 10
```

所以说，Go 语言和 C、C++ 以及 D 语言这些低级（系统）语言一样，都有指针的概念。==但是对于经常导致 C 语言内存泄漏继而程序崩溃的指针运算（所谓的指针算法，如：`pointer+2`，移动指针指向字符串的字节数或数组的某个位置）是不被允许的。==因此 `c = *p++` 在 Go 语言的代码中是不合法的。



**注意事项2**

对一个空指针的反向引用是不合法的，并且会使程序崩溃

```go
package main
func main() {
	var p *int = nil
	*p = 0
}
// in Windows: stops only with: <exit code="-1073741819" msg="process crashed"/>
// runtime error: invalid memory address or nil pointer dereference
```



**指针的好处**

- 可以传递一个变量的引用（如函数的参数），这样不会传递变量的拷贝。当程序在工作中需要占用大量的内存，或很多变量，或者两者都有，使用指针会减少内存占用和提高效率。被指向的变量也保存在内存中，直到没有任何指针指向它们，所以从它们被创建开始就具有相互独立的生命周期。

**指针的弊端**

- 另一方面（虽然不太可能），由于一个指针导致的间接引用（一个进程执行了另一个地址），指针的过度频繁使用也会导致性能下降。

- 指针也可以指向另一个指针，并且可以进行任意深度的嵌套，导致你可以有多级的间接引用，但在大多数情况这会使你的代码结构不清晰。



在大多数情况下 Go 语言可以使程序员轻松创建指针，并且==隐藏间接引用==，如：自动反向引用。

> 隐藏间接引用，在之后的结构体之中体现的更加明显，这是Go语言支持的一个语法糖
>
> 语法糖：指计算机语言中添加的某种语法，这种语法对语言的功能并没有影响。通常来说使用语法糖能够增加程序的可读性，从而减少代码出错的机会。
>
> stu是一个student结构体的指针，要调用成员变量，应为
>
> (*stu).age，但Go语言内部支持stu.age这种方式。
>
> 能支持这种方式调用的本质原因是Go不支持对指针的修改





## 值类型与引用类型

**值类型**：值类型的变量的值存储在栈中。

`int`、`float`、`bool` 和 `string` 这些基本类型都属于值类型，使用这些类型的变量直接指向存在内存中的值。

[![img](4.1.assets/4.4.2_fig4.1.jpg)](https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/images/4.4.2_fig4.1.jpg?raw=true)



另外，像`array`、`struct`这些复合类型也是值类型。

当使用等号 `=` 将一个变量的值赋值给另一个变量时，如：`j = i`，实际上是在内存中将 i 的值进行了拷贝：

[![img](4.1.assets/4.4.2_fig4.2.jpg)](https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/images/4.4.2_fig4.2.jpg?raw=true)



**引用类型**：被引用的变量会存储在堆中，以便进行垃圾回收，且比栈拥有更大的内存空间。

更复杂的数据，例如`ptr`、`slice`、`map`、`channel`、`func`、`interface`通常会需要使用多个字，这些数据一般使用引用类型保存。

一个引用类型的变量 r1 存储的是 r1 的值所在的内存地址（数字），或内存地址中第一个字所在的位置。这个内存地址被称之为指针，这个指针实际上也被存在另外的某一个字中。

[![img](008%20%E6%8C%87%E9%92%88.assets/4.4.2_fig4.3.jpg)](https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/images/4.4.2_fig4.3.jpg?raw=true)

- 同一个引用类型的指针指向的多个字可以是在连续的内存地址中（内存布局是连续的），这也是计算效率最高的一种存储形式；也可以将这些字分散存放在内存中，每个字都指示了下一个字所在的内存地址。


- 当使用赋值语句 `r2 = r1` 时，只有引用（地址）被复制。


- 如果 r1 的值被改变了，那么这个值的所有引用都会指向被修改后的内容，在这个例子中，r2 也会受到影响。


