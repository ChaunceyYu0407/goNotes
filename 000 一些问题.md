# 一些需要继续深入讨论的问题

## 1 关于Go中的编译

- 如果想要构建一个程序，那么包和包内的程序都必须以正确的顺序进行编译。

- 包的依赖顺序决定了其构建顺序。

- 一个包是编译时的一个单元，属于同一个包的源文件必须全部被一起编译，因此一个目录只含一个包。
- ==如果对一个包进行更改或重新编译，所有引用这个包的客户端程序都必须全部重新编译。==

> 这个是什么意思，例如main包中main.go引用了 test包中的struct，函数等
>
> 此时我修改了test包中的相关东西，那么main.go需要重新编译？
>
> 意思是此前的exe文件没用了，依然是之前版本的test包？

- Go中的包模型采用了==显示依赖关系的机制==来达到快速编译的目的，编译器会从后缀名为`.o`的对象文件（==需要且只需要这个文件==）中提取传递依赖类型的信息。

> 如果`A.go`依赖`B.go`，而`B.go`又依赖`C.go`
>
> 编译`C.go`，`B.go`，然后是`A.go`
>
> 为了编译`A.go`，编译器读取的`B.o`，而不是`C.o`
>
> 这种机制对于编译大型项目时可以显著地提升编译速度。？？？

- 每一段代码只会被编译一次

- 如果打算从已编译的包中导入并加载公开声明的方法，不需要插入已编译的源代码

> 什么意思，我记得C++是插入代码片段的？这里是直接从.o中读取的吗？



## 2 go run和go build的区别

https://blog.csdn.net/weixin_31787977/article/details/112576794

==还有一个问题是go build `./xxxx.go`可以吗，可以用相对路径吗？==

*引用：Go programs cannot use relative import paths within a work space.*

*注解：在GOPATH外可以以相对路径的形式执行go build（go install 不可以）*

